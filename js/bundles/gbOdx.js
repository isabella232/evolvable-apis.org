var pageComponent=webpackJsonppageComponent([4],{284:function(e,t,o){"use strict";function r(e){return e&&e.__esModule?e:{default:e}}function a(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function n(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!=typeof t&&"function"!=typeof t?e:t}function i(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}Object.defineProperty(t,"__esModule",{value:!0});var s=o(1),l=r(s),h=o(2),p=r(h);o(5),o(6),o(7),o(8),o(9),o(10),o(11),o(12),o(13),o(14),o(15),o(16),o(17),o(18),o(19);var u=o(285),d=r(u),c=function(e){function t(){return a(this,t),n(this,(t.__proto__||Object.getPrototypeOf(t)).apply(this,arguments))}return i(t,e),t}(l.default);p.default.register(c,d.default),t.default=c},285:function(e,t,o){"use strict";function r(e){return e&&e.__esModule?e:{default:e}}function a(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function n(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!=typeof t&&"function"!=typeof t?e:t}function i(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}Object.defineProperty(t,"__esModule",{value:!0}),t.templates=t.gbOdx=void 0;var s,l=o(1),h=r(l),p=o(2),u=r(p);goog.loadModule(function(e){function t(e,t,r){var s=function(){a("article",null,null,"id","1"),a("h2"),i("Context"),n("h2"),a("p"),i("Most of the times, an API models not only a single resource, but a bigger or smaller bunch of them. Thus, there will probably be different endpoints in the API to retrieve or operate with different kind of resources."),n("p"),a("p"),i("For example, if there is an Endpoint to retrieve information about a member:"),n("p"),h({code:"GET /api/member/15",mode:"text"},null,r),a("p"),i("that will return"),n("p"),h({code:'{\n      "gender": "female",\n      "alias": "Sophie",\n      "name": "Sophia Hart",\n      "birthDate": "1975-04-12T00:00Z",\n      "email": "sophia.hart@example.com"\n}',mode:"javascript"},null,r),a("p"),i("Let’s suppose that the API provider, also keeps the articles, or blog posts, or short publications (aka micro-posts) that members can write. So, let’s say in this case that there is  another endpoint to return an specific published micro-message:"),n("p"),h({code:"GET /api/posts/42",mode:"text"},null,r),h({code:'{\n    "articleBody" : "Creating Evolvable APIs is possible. See http://evolvable-apis.org",\n    "dateCreated" : "2018-04-12T19:57Z",\n    "author" : "15"\n}',mode:"javascript"},null,r),a("p"),i("So, in this case there are two different resources that have some kind of relationship between them: the members create posts, and the posts are authored by a member."),n("p"),n("article"),a("article",null,null,"id","2"),a("h2"),i("Need"),n("h2"),a("p"),i("The most probable situation for customers consuming this API will be that they want to show, not only the post content, but also some information about the author (at least the name)."),n("p"),a("p"),i("With the current API design, those customers, will need to make two requests: one for the post and, once the author_id is parsed, another one to retrieve the author name and any other member information useful to show together with the micro-post (i.e the user profile picture)."),n("p"),a("p"),i("The situation gets worse in the case that the endpoint used returns a collection with the latest 50 messages, because you will (in worst case) increase the number of request to 51: one for the collection of messages and then, one for each of the authors of the messages. (You could cache the information of authors in case some messages are written by the same member, but if you have too many different members, you could end up again doing 51 requests to the server)."),n("p"),n("article"),a("article",null,null,"id","3"),a("h2"),i("Solution"),n("h2"),a("p"),i("We need to address a couple of changes in this context."),n("p"),a("h3"),i("Step one: Declare relationships between resources."),n("h3"),a("p"),i("The first task that we should deal with is how we express that the author is a relationship with another entity."),n("p"),a("p"),i('With the approach shown, there is no way to know that the value of the "author" attribute is an id for another resource represented under other URL. There is no specific info that helps the customer to know if that “15” value is the id, or the name, or an alias, (or any other attribute) from the author. On top of that, there is no specific information on how to access the rest of the information of the author.'),n("p"),a("p"),i('A first idea could be changing the name of the attribute name from "author" to “author_id” to express that this is, in fact, an Id of another resource. But this still does not completely give semantic information on how a client should deal with author Id.'),n("p"),a("p"),i("Instead, we should declare specifically in our contract, that the author is, in fact, a relationship with another resource. For example, "),a("a",null,null,"href","https://tools.ietf.org/html/draft-kelly-json-hal-08#page-4"),i("HAL"),n("a"),i(' specification for _links, reserves the attribute "_links" to add all the attributes that are relation types.'),n("p"),a("p"),i("That way, our representation could have this structure:"),n("p"),h({code:'{\n  "_links" : {\n    "author" : { "href" : "http://example.org/api/member/15"}\n  },\n  "articleBody" : "Creating Evolvable APIs is possible. See http://evolvable-apis.org",\n  "dateCreated" : "2018-04-12T19:57Z",\n}',mode:"javascript"},null,r),a("p"),i('Once that the response format includes the specific links, it is also a good practice to introduce a special link, under the attribute of "_self",  which contains the URL to the resource described in the document:'),n("p"),h({code:'{\n  "_links" : {\n    "self" : { "href" : "http://example.org/api/posts/42" },\n    "author" : { "href" : "http://example.org/api/member/15" }\n  },\n  "articleBody" : "Creating Evolvable APIs is possible. See http://evolvable-apis.org",\n  "dateCreated" : "2018-04-12T19:57Z",\n}',mode:"javascript"},null,r),a("p"),i("This structure is one possible solution to express relationships between resources as specified by HAL. There are other alternatives following JSON-API, Siren, … follow the format that best fits your needs."),n("p"),a("h4"),i("Step two: Embed the related resource"),n("h4"),a("p"),i('With the previous step, the relationship for the attribute "author" is more clearly defined and the semantic of how to use that is already defined by the fact that is marked as a link. But, still, the client will need to make a second request to retrieve the details of the member who wrote the message as it is specified in the related URL.'),n("p"),a("p"),i("In order to avoid that second request the API should provide a way to allow the customer to specify the nested information that they are interested in the very first request."),n("p"),a("p"),i("For that purpose the API implementor should check the query string and look if a ‘includes’ parameter is present. The value of that parameter should be handled by the API provider as a comma-separated list of the different relationships that should be included on the response."),n("p"),a("p"),i("In the case of the example, to get the message with id 42 including all the information about the author, the customer will simply send the following request:"),n("p"),h({code:"GET /api/posts/42?includes=author",mode:"text"},null,r),a("p"),i('This way, the API provider will know that it needs to also retrieve and return the embedded data for the author. Following the JSON-API format, the provider should add the author data o a new "included" attribute of the Json returned:'),n("p"),h({code:'{\n  "_links" : {\n    "self" : { "href" : "http://example.org/api/posts/42" },\n    "author" : { "href" : "http://example.org/api/member/15" }\n  },\n  "articleBody" : "Creating Evolvable APIs is possible. See http://evolvable-apis.org",\n  "dateCreated" : "2018-04-12T19:57Z",\n  "_embedded" : {\n    "author" : {\n      "_links" : {\n        "self" :  { "href" : "http://example.org/api/member/15" }\n      },\n      "id" : "15",\n      "gender": "female",\n      "alias": "Sophie",\n      "name": "Sophia Hart",\n      "birthDate": "1975-04-12T00:00Z",\n      "email": "sophia.hart@example.com"\n    }\n  }\n}',mode:"javascript"},null,r),a("h4"),i("Step three: Specifying which attributes of the embedded resource should be included"),n("h4"),a("p"),i("We could go further to allow the customer to specify which fields (attributes) of the embedded resource should be included."),n("p"),a("p"),i("Combining the embedding with the sparse-fieldset feature, the customer could combine the include and fields param in the query string to whitelist the attributes that should be included in the response."),n("p"),a("p"),i("By default, as it is explained on the sparse-fieldsets recipe, the values specified in the fields param refers to the main resource requested in the URL, but whe can refer to the embedded resource by adding the entity type between brackets."),n("p"),a("p"),i("So, a request like"),n("p"),h({code:"GET /api/posts/42?include=author&fields[person]=name",mode:"text"},null,r),a("p"),i("Instructs the API provider to simply add the name of the embedded resource:"),n("p"),h({code:'{\n  "_links" : {\n    "self" : { "href" : "http://example.org/api/posts/42" },\n    "author" : { "href" : "http://example.org/api/member/15" }\n  },\n  "articleBody" : "Creating Evolvable APIs is possible. See http://evolvable-apis.org",\n  "dateCreated" : "2018-04-12T19:57Z",\n  "_embedded" : {\n    "author" : {\n      "_links" : {\n        "self" :  { "href" : "http://example.org/api/member/15" }\n      },\n      "name": "Sophia Hart"\n    }\n  }\n}',mode:"javascript"},null,r),a("p"),l({section:e.page},null,r),n("p"),n("article"),a("input",null,null,"type","hidden","value",e.page.title),n("input"),a("input",null,null,"type","hidden","value",e.site.title),n("input")};p(o.$$assignDefaults({content:s},e),null,r)}goog.module("gbOdx.incrementaldom");var o=goog.require("soy");goog.require("soydata");goog.require("goog.asserts"),goog.require("soy.asserts"),goog.require("goog.i18n.bidi"),goog.require("goog.string");var r=goog.require("incrementaldom"),a=r.elementOpen,n=r.elementClose,i=(r.elementVoid,r.elementOpenStart,r.elementOpenEnd,r.text),l=(r.attr,u.default.getTemplate("DocsList.incrementaldom","render")),h=u.default.getTemplate("ElectricCode.incrementaldom","render"),p=u.default.getTemplate("guide.incrementaldom","render");return e.render=t,goog.DEBUG&&(t.soyTemplateName="gbOdx.render"),e.render.params=["page","site"],e.render.types={page:"?",site:"?"},e.templates=s=e,e});var d=function(e){function t(){return a(this,t),n(this,(t.__proto__||Object.getPrototypeOf(t)).apply(this,arguments))}return i(t,e),t}(h.default);u.default.register(d,s),t.gbOdx=d,t.templates=s,t.default=s}},[284]);