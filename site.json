{"title":"Evolvable APIs","githubRepo":"liferay/evolvable-apis.org","googleAnalytics":"UA-37033501-12","index":{"title":"Home","description":"Embrace rapid evolution without breaking consumers.","content":" 2018 MIT License Powered by WeDeploy™ ","srcFilePath":"src/pages/index.soy","id":"pages","location":"/./","url":"/./","children":{"docs":{"title":"Docs","url":"/docs/introduction/index.html","layout":false,"content":" ","srcFilePath":"src/pages/docs/index.soy","id":"docs","location":"/docs/","customURL":true,"children":{"search":{"description":"Documentation search results.","hidden":true,"title":"Search","content":" Electric Docs Start learning how to leverage the power of Electric. ","srcFilePath":"src/pages/docs/search.soy","id":"search","location":"/docs/search.html","url":"/docs/search.html"},"introduction":{"title":"Introduction to Evolvable APIs","description":"Evolvable REST APIs are specially useful in contexts where the consumers are not written by the same development team as the server side API. Even more so, when the deployment and update of the consumers is specially challenging, as happens with native mobile applications and even more so, consumers present in IoT devices.","layout":"guide","icon":"streams","weight":1,"content":" {$page.description} What makes an API Evolvable? Long story short, an evolvable APIs is an API that has been designed to facilitate seamless evolution. This is achieved through set of characteristics, design principles and capabilities that confer the API the capability of evolving and adapting to changes without breaking clients that are already consuming it. And at the same time they allow clients to use them in a way that can discover new capabilities and enhance its behaviour automatically when that evolution happens. This could sounds like an chasing “El Dorado”, like an impossible goal to reach, but in fact it is not. The web is almost 30 years old. If something has been proven key, is the capability of the Web to evolve gracefully over the years. Can we learn something from the web? Can we reuse any of its design principles for our own Web APIs? Can we prepare them to evolve as seamlessly as the Web? If we take a look at how some APIs are built today, we could think that unfortunately we can’t. It’s common in these days to be forced to update clients because a minor feature has been removed, changed or added in the server side. Any API can become more evolvable and it’s our goal to show how. But we think that, when necessary, we can bring some of those design principles and characteristics into the way we design and build Web APIs and take most of the benefits of Evolvability. Should your API be evolvable? The quick answer is “It depends”. This is not a matter of black and white, of what is right and what is wrong. We are not trying to establish what is better in absolute terms. Whenever it comes to designing your Web API, the first question you should ask yourself is What are your -or your customer’s- needs? To facilitate with the decision making, this website has been organized in the form of some introductory articles to provide base knowledge and a collection of recipes. Each recipe addresses a real world challenge and proposes one or more ways to solve it following an evolvable approach. The recipes explain the context as well as the benefits and costs to facilitate deciding whether it should be applied to your particular scenario. Maybe you will discover that some solutions or techniques are a great fit for your API while others are not. That’s perfectly fine, nobody knows better than you what your API needs. {call DocsList.render} {param section: $page /} {/call} ","srcFilePath":"src/pages/docs/introduction/index.md","id":"introduction","location":"/docs/introduction/","url":"/docs/introduction/","children":{"techniques":{"title":"Foundational techniques to make your APIs evolvable","description":"","layout":"guide","icon":"flash","weight":2,"content":" As stated in the previous sections, there are several different facets that help to build Evolvable APIs. There are some which can be considered as techniques that can be implemented in different ways (like Hypermedia, which is a concept but can several different implementations), other are a set of guidelines, patterns or standards. We can consider it as the building blocks that make possible Evolvable APIs. Hypermedia Consumers, like mobile apps, should not hardcode the navigation from one user interface (let it be a screen, a web page or a panel) to another. It should neither specify directly the actions that the user can take in each screen. Then, how can consumers of an API face the navigation of the application through all the different unknown possibilities that hide behind the API contract? To enable this, each API response should provide a list of possible operation as either read-only links or actions. Each operation has a type (e.g., IANA link relations) that the consumer knows how to deal with (e.g., follow a link automatically, present an action to a user, etc...). APIs using hypermedia let the API provider control the available operations, which simplifies the consumer and decouples it from the server. To support a wide variety of functionality provided by an API, a consumer only needs to support one standard hypermedia format, and follow standard link types (e.g., IANA link relations). That way, Hypermedia, can be seen as the mechanism that enables the autodiscovering (or scouting) of all the different resources, and actions that the server can provide. Shared Vocabularies Use carefully crafted message types that are focused on the needs of the consumers, instead of how the API is implemented today. It’s useful to speak a language that will result familiar to the developers of clients for your APIs. Using the same language means less misunderstandings, and it eases other participants to start talking to your API. Using your own slang or assigning specific meanings you only know, will make more difficult to others to understand what you are saying. Any organization, group or individual has a different way to communicate depending on the context in which they are. For example: you can refer to things with an informal name when you are talking to your kids, or you can use slang when talking with your friends, or you can have specific aliases or specific names for certain concepts inside your company, even specific properties…. But when you need to communicate with the external world, let’s say you need to write an article for the press, negotiate something with someone that does not belong to your inner circle, or prepare some marketing messages, in that case, you will probably switch to a common standard way of expressing things to ensure that your partner understands the same thing you are expressing. That is: when you get out of your inner group, organization or ambient, you won’t want to use your specific words that maybe you only understand, you will use the concepts and words that you know everyone out there will assign the same meaning that you. With your API the same rule applies: Your internal model, your concrete naming, your specific attributes should be kept for your inner realm. Instead, you should expose the resources, attributes and concepts with not only a naming, also a structure, typing and possible constraint rules on its values that are of common use. That way you can leverage your API to be well used by a broad set of consumers, that will be understanding and using your contract with a common meaning. For that matter, there are some already agreed standard vocabularies (e.g, schema.org) that you can use and even extend if you need to. But the key point here is that you are using a common way to name and structure the model you expose. Of course, that will mean that you need to find a way to ‘translate’ between your internal model and the public model using that standard vocabularies. But you can use the Representor pattern to accomplish that and decouple the internal model and external contract. The main benefit of leveraging standard vocabularies is that API developers can make internal changes freely. Consumer developers therefore benefit from much more reuse across applications. Standards Part of the key to succeed in any environment is the ability to do the things in the same way that everyone does, that is sticking to the standards. And that’s what also made the Web succeed, scale and adapt to the evolution. For your API, you will find useful to use Standards whenever they are available and they address one of your needs. For example: HTTP as communication protocol (not just transport protocol), with their methods, headers, response codes and all the semantics that are already defined in it. Have I heard anyone thinking in REST? ;) Hypermedia MIME types. Choose at least one (or more) of the defined standards to communicate the navigation and options that the client can take. There are several different ones: HAL, Siren, JSON-LD, Collection+JSON… Read of them and chose whichever best fits your needs. IANA Link Relations. If you need to add links between resources. Some Hypermedia Types are already using IANA Link Relations. {call DocsList.render} {param section: $page /} {/call} ","srcFilePath":"src/pages/docs/introduction/techniques.md","id":"techniques","location":"/docs/introduction/techniques.html","url":"/docs/introduction/techniques.html"},"versioning":{"title":"Versioning your API contract","description":"","layout":"guide","icon":"flash","weight":3,"content":" Versions Every API defines a contract that the clients depend on. The contract may be composed of URLs, HTTP methods, error codes, message types, input params and much more. If the contract changes in a backwards incompatible way it is likely that consumers will break. What’s the best way to deal with that situation? The most evolvable way is by making your contract small enough and solid enough that you will never need to break backwards compatibility. This may sound too idealistic for people who are used to API contracts which very large surface areas such as a large list of resource URLs with careful documentation for what can be done with each of them, the input and output formats, error codes, etc. But by applying the recipes from this website you will find ways to reduce the size of the API contract, and then, not breaking backwards compatibility suddenly doesn’t seem so difficult. However, in some cases, it might be necessary to make backwards incompatible changes. In that case versioning is the least bad option. But there are many ways of doing versioning, what is the best way of doing it? Here are some suggestions: Don’t version upfront unless you know for sure that you will need to break backwards compatibility. Avoid versioning the whole API if only certain parts of it will have to change in a backwards incompatible way. Isolate the areas of the API that might have to be changed. Try to find a way to not make them part of the contract and use some discoverability features instead. For that areas where it’s not possible find a way to version only the bare minimum, for example through MIME type versioning. {call DocsList.render} {param section: $page /} {/call} ","srcFilePath":"src/pages/docs/introduction/versioning.md","id":"versioning","location":"/docs/introduction/versioning.html","url":"/docs/introduction/versioning.html"}},"childIds":["techniques","versioning"]},"recipes":{"title":"Recipes (towards Evolvable APIs)","description":"Making an API Evolvable is about how many different challenges are designed or implemented when we build it. Maybe you do not need to solve all of them for your case. In this section, we will provide some individual recipes on how to address each of this facets.","layout":"guide","icon":"streams","weight":1,"content":" Recipes index {$page.description} The following articles, will address specific needs and challenges that might appear while designing an API and suggests evolvable solutions. Or, maybe you do not need to make your API evolvable but you find that you can get the benefit of some of them. Read through the set of recipes and take their advice in them, here you have the menu: Pagination Sparse fieldsets and more to come... {call DocsList.render} {param section: $page /} {/call} ","srcFilePath":"src/pages/docs/recipes/index.md","id":"recipes","location":"/docs/recipes/","url":"/docs/recipes/","children":{"non-crud-operations":{"title":"Non-CRUD operations","description":"","layout":"guide","icon":"flash","weight":3,"content":" Context Once that we model our API to represent resources and accept operations on that resources, we will probably end with a set of resources (Nouns) that can be Created, Retrieved, Updated and Deleted. But then we can probably find ourselves in situation in which we want to model an operation which is going to trigger some unknown set of operations (from the point of view of the API customer) that will eventually change the state of the resource that we have model. For example, let’s say that we have modelled our Members can be promoted to a different role (like site admins), and that will probably assign them new roles or modify some status. For example you have your: GET /api/member/15 That returns the following representation: { \"gender\": \"female\", \"alias\": \"Sophie\", \"name\": \"Sophia Hart\", \"birthDate\": \"1975-04-12T00:00Z\", \"email\": \"sophia.hart@example.com\", \"memberOf\": \"regularUser\" } Need If you want to allow the possibility of clients adding the user to a new role, or group, you could argue that you could use a PUT updating the info of the member attribute to have the new desired role also. But if that state change need to be approved by a supervisor, or implies that the user needs to confirm some of the step (like reading and accepting an agreement that is going to be sent on his email)? In that case, what we are trying to add to our API is an action, an update that needs to trigger a set of actions, and maybe is going to take some time to update. Solution In this case, we need to rethink about that request in terms of intermediate state, and requests that can be referenced in time or, by the API consumers, in terms of something related to the resource we are modeling That resource, in our case, it’s the original member, and that ‘something’ implies that the process of changing the state of our original resource (the member) is, in fact, also a noun (another resource) with a relationship with the member. In this case, we could design our API to accept to post a new MembershipRequest linked to a member for a particular Role. (Nouns, or resources, are marked in bold). So, the original problem can be addressed by providing an endpoint to which we can make a POST POST /api/member/15/membership-request Modelling the state change as a request that will start a process (the review and approval) which eventually will end updating the attribute of our member has several different benefits: The request, as now is another noun, can be referenced We can track the status of the process, as long the request is linked to our original resource (the member) When the process is finished, if the API implementor decides to not delete the request once it is approved or rejected, we can have an historical record of what caused the change. {call DocsList.render} {param section: $page /} {/call} ","srcFilePath":"src/pages/docs/recipes/non-crud-operations.md","id":"non-crud-operations","location":"/docs/recipes/non-crud-operations.html","url":"/docs/recipes/non-crud-operations.html"},"pagination":{"title":"Pagination","description":"","layout":"guide","icon":"flash","weight":2,"content":" Context Let’s say that you have created a service that returns the list of members (persons) of your site. Initially, you modeled the list to contain the basic information for each of those persons: GET api/members And the service returns that list, for example with the following structure: { \"members\" : [ { \"gender\": \"female\", \"name\": \"Sophia Hart\", \"birthDate\": \"1975-04-12T00:00Z\", \"email\": \"sophia.hart@example.com\", }, { \"gender\": \"male\", \"name\": \"John Doe\", \"birthDate\": \"1977-03-15T00:00Z\", \"email\": \"john.doe@email.com\", } ] } And it seems right at first, it serves it purpose. But soon new members start to register to your site, and the list starts growing, and growing until it reaches for example 1.000 users. That’s a big amount of information to retrieve at once, and, on top of that, probably your API consumer is not going to show to its user all that information at once (the user probably won’t go through a 1.000 items list in any case). Need At that point you decide that you need to add some pagination mechanism (you will also add want to add filtering mechanisms to your API, but you still will benefit from pagination in the case the request does not include any filtering criteria). Solution So, let’s start with an outline of which information is important to handle the pagination: The first, of course is the list of contents (in this case, the members). That does not change Adding information on the page in which you are, the number of elements contained on the page, optionally the total number of elements (or approximation) or the total number of pages. Some links to navigate to The next page of the search (if there is one)s The previous page (if you are not returning the first one) The very first page. Optionally the very last page. So, the first change to our response design will be to wrap, or embed the list of items in an specific property which contains that list: { \"_embedded\" : { \"members\" : [ /.../ ] } } Now we can add the information of the number of elements, and how many elements we are returning as part of the current page: { \"count\" : 20, \"total\" : 1017, \"_embedded\" : { \"members\" : [ /.../ ] } } Now, the last step is adding, information to allow to navigate to the first, previous and/or next pages, depending on the page that your are returning. In order to add those links, we are going to stick to the standards, and there is one that addresses specifically how to add links: The IANA Link relations. We will group all those navigation links under the same attribute: { \"_links\": { \"self\": { \"href\": \"http://example.org/api/members?page=3\" }, \"first\": { \"href\": \"http://example.org/api/members\" }, \"prev\": { \"href\": \"http://example.org/api/members?page=2\" }, \"next\": { \"href\": \"http://example.org/api/members?page=4\" }, \"last\": { \"href\": \"http://example.org/api/members?page=51\" } }, \"count\" : 20, \"total\" : 1017, \"_embedded\" : { \"members\" : [ { \"gender\": \"female\", \"name\": \"Sophia Hart\", \"birthDate\": \"1975-04-12T00:00Z\", \"email\": \"sophia.hart@example.com\", }, { \"gender\": \"male\", \"name\": \"John Doe\", \"birthDate\": \"1977-03-15T00:00Z\", \"email\": \"john.doe@email.com\", } ] } } In this example, we have used the structure and attribute names that HAL proposes. There are some other alternatives based on Collection+JSON, Siren, or others. {call DocsList.render} {param section: $page /} {/call} ","srcFilePath":"src/pages/docs/recipes/pagination.md","id":"pagination","location":"/docs/recipes/pagination.html","url":"/docs/recipes/pagination.html"},"resource-embedding":{"title":"Resource embedding","description":"","layout":"guide","icon":"flash","weight":4,"content":" Context Most of the times, an API models not only a single resource, but a bigger or smaller bunch of them. Thus, there will probably be different endpoints in the API to retrieve or operate with different kind of resources. For example, if there is an Endpoint to retrieve information about a member: GET /api/member/15 that will return { \"gender\": \"female\", \"alias\": \"Sophie\", \"name\": \"Sophia Hart\", \"birthDate\": \"1975-04-12T00:00Z\", \"email\": \"sophia.hart@example.com\" } Let’s suppose that the API provider, also keeps the articles, or blog posts, or short publications (aka micro-posts) that members can write. So, let’s say in this case that there is another endpoint to return an specific published micro-message: GET /api/posts/42 { \"articleBody\" : \"Creating Evolvable APIs is possible. See http://evolvable-apis.org\", \"dateCreated\" : \"2018-04-12T19:57Z\", \"author\" : \"15\" } So, in this case there are two different resources that have some kind of relationship between them: the members create posts, and the posts are authored by a member. Need The most probable situation for customers consuming this API will be that they want to show, not only the post content, but also some information about the author (at least the name). With the current API design, those customers, will need to make two requests: one for the post and, once the author_id is parsed, another one to retrieve the author name and any other member information useful to show together with the micro-post (i.e the user profile picture). The situation gets worse in the case that the endpoint used returns a collection with the latest 50 messages, because you will (in worst case) increase the number of request to 51: one for the collection of messages and then, one for each of the authors of the messages. (You could cache the information of authors in case some messages are written by the same member, but if you have too many different members, you could end up again doing 51 requests to the server). Solution We need to address a couple of changes in this context. Step one: Declare relationships between resources. The first task that we should deal with is how we express that the author is a relationship with another entity. With the approach shown, there is no way to know that the value of the \"author\" attribute is an id for another resource represented under other URL. There is no specific info that helps the customer to know if that “15” value is the id, or the name, or an alias, (or any other attribute) from the author. On top of that, there is no specific information on how to access the rest of the information of the author. A first idea could be changing the name of the attribute name from \"author\" to “author_id” to express that this is, in fact, an Id of another resource. But this still does not completely give semantic information on how a client should deal with author Id. Instead, we should declare specifically in our contract, that the author is, in fact, a relationship with another resource. For example, HAL specification for \\links, reserves the attribute \"\\links\" to add all the attributes that are relation types. That way, our representation could have this structure: { \"_links\" : { \"author\" : { \"href\" : \"http://example.org/api/member/15\"} }, \"articleBody\" : \"Creating Evolvable APIs is possible. See http://evolvable-apis.org\", \"dateCreated\" : \"2018-04-12T19:57Z\", } Once that the response format includes the specific links, it is also a good practice to introduce a special link, under the attribute of \"\\_self\", which contains the URL to the resource described in the document: { \"_links\" : { \"self\" : { \"href\" : \"http://example.org/api/posts/42\" }, \"author\" : { \"href\" : \"http://example.org/api/member/15\" } }, \"articleBody\" : \"Creating Evolvable APIs is possible. See http://evolvable-apis.org\", \"dateCreated\" : \"2018-04-12T19:57Z\", } This structure is one possible solution to express relationships between resources as specified by HAL. There are other alternatives following JSON-API, Siren, … follow the format that best fits your needs. Step two: Embed the related resource With the previous step, the relationship for the attribute \"author\" is more clearly defined and the semantic of how to use that is already defined by the fact that is marked as a link. But, still, the client will need to make a second request to retrieve the details of the member who wrote the message as it is specified in the related URL. In order to avoid that second request the API should provide a way to allow the customer to specify the nested information that they are interested in the very first request. For that purpose the API implementor should check the query string and look if a ‘includes’ parameter is present. The value of that parameter should be handled by the API provider as a comma-separated list of the different relationships that should be included on the response. In the case of the example, to get the message with id 42 including all the information about the author, the customer will simply send the following request: GET /api/posts/42?includes=author This way, the API provider will know that it needs to also retrieve and return the embedded data for the author. Following the JSON-API format, the provider should add the author data o a new \"included\" attribute of the Json returned: { \"_links\" : { \"self\" : { \"href\" : \"http://example.org/api/posts/42\" }, \"author\" : { \"href\" : \"http://example.org/api/member/15\" } }, \"articleBody\" : \"Creating Evolvable APIs is possible. See http://evolvable-apis.org\", \"dateCreated\" : \"2018-04-12T19:57Z\", \"_embedded\" : { \"author\" : { \"_links\" : { \"self\" : { \"href\" : \"http://example.org/api/member/15\" } }, \"id\" : \"15\", \"gender\": \"female\", \"alias\": \"Sophie\", \"name\": \"Sophia Hart\", \"birthDate\": \"1975-04-12T00:00Z\", \"email\": \"sophia.hart@example.com\" } } } Step three: Specifying which attributes of the embedded resource should be included We could go further to allow the customer to specify which fields (attributes) of the embedded resource should be included. Combining the embedding with the sparse-fieldset feature, the customer could combine the include and fields param in the query string to whitelist the attributes that should be included in the response. By default, as it is explained on the sparse-fieldsets recipe, the values specified in the fields param refers to the main resource requested in the URL, but whe can refer to the embedded resource by adding the entity type between brackets. So, a request like GET /api/posts/42?include=author&fields[person]=name Instructs the API provider to simply add the name of the embedded resource: { \"_links\" : { \"self\" : { \"href\" : \"http://example.org/api/posts/42\" }, \"author\" : { \"href\" : \"http://example.org/api/member/15\" } }, \"articleBody\" : \"Creating Evolvable APIs is possible. See http://evolvable-apis.org\", \"dateCreated\" : \"2018-04-12T19:57Z\", \"_embedded\" : { \"author\" : { \"_links\" : { \"self\" : { \"href\" : \"http://example.org/api/member/15\" } }, \"name\": \"Sophia Hart\" } } } {call DocsList.render} {param section: $page /} {/call} ","srcFilePath":"src/pages/docs/recipes/resource-embedding.md","id":"resource-embedding","location":"/docs/recipes/resource-embedding.html","url":"/docs/recipes/resource-embedding.html"},"sparse-fieldsets":{"title":"Sparse Fieldsets","description":"","layout":"guide","icon":"flash","weight":3,"content":" Context Sometimes our API returns a representation for a resource which includes a lot of information that the API provider keeps on the information, but if you think on the different kind of consumers that you will serve and, more specifically, the possible constraints that they have, maybe it’s useful if your API allows them to specify a shorter list of attributes that they want to retrieve (instead of the whole representation of the resource). Need For example, think on an IoT device, which is interested in using just a single property (or a few information) of the resource for which is requesting a representation. If you also take into account that maybe the device is sending the request (and retrieving the response) using a connection that does not has very good bandwidth, it makes more sense to allow to send back just 1Kb of data, that corresponds to the information that the consumer really is interested in, instead of -let’s say- the 14kb of data used for the represent the resource in its full extend. Another scenario in which filtering this feature for your API could be useful is when a mobile application is retrieving a representation of a resource, but, because the space constraints of the screen in which that information will be displayed, some of the attributes will not be rendered. Here, the mobile app -your API customer in this case- will benefit of a more effective bandwidth usage if they can just inform your API which information they are interested in. So, how the API provider can allow the customer to specify the specific information that they want in the response? Let’s start from our service that returns the information for a member (a person) of our site: GET /api/member/15 And the server’s response includes the following representation of the requested person: { \"gender\": \"female\", \"alias\": \"Sophie\", \"name\": \"Sophia Hart\", \"jobTitle\" : \"Senior Executive\", \"birthDate\": \"1975-04-12T00:00Z\", \"birthPlace\" : { \"@type\": \"Place\", \"address\": { \"@type\": \"PostalAddress\", \"addressLocality\": \"Philadelphia\", \"addressRegion\": \"PA\" } }, \"email\": \"sophia.hart@example.com\", \"telephone\": \"555-984-394\" } Let’s say that the customer is just going to show the contact data for the user: the name, the job title and email and phone if they are present. Solution We can prepare the API so that the list of requested fields can be specified in the URL of the request, using the fields param with a comma separated list of the attributes. GET /api/member/15?fields=name,jobTitle,email,telephone And the API provider will reply with a partial response like the following one: { \"name\": \"Sophia Hart\", \"jobTitle\" : \"Senior Executive\", \"email\": \"sophia.hart@example.com\", \"telephone\": \"555-984-394\" } For this feature, it’s really useful the use of Shared Vocabularies (i.e resources represented following the definition in schema.org) it will allow the client to know beforehand the list of fields that wants in the response, even without doing any initial request to examine the structure of the response. The usefulness of this feature can be even better when we add this support to collections. For example compare: GET api/members And the subsequent response with all the information: { \"members\" : [ { \"gender\": \"female\", \"alias\": \"Sophie\", \"name\": \"Sophia Hart\", \"jobTitle\" : \"Senior Executive\", \"birthDate\": \"1975-04-12T00:00Z\", \"birthPlace\" : { \"@type\": \"Place\", \"address\": { \"@type\": \"PostalAddress\", \"addressLocality\": \"Philadelphia\", \"addressRegion\": \"PA\" } }, \"email\": \"sophia.hart@example.com\", \"telephone\": \"555-984-394\" }, { \"gender\": \"male\", \"alias\": \"jdoe\", \"name\": \"John Doe\", \"jobTitle\": \"Sales Manager\", \"birthDate\": \"1977-03-15T00:00Z\", \"birthPlace\" : { \"@type\": \"Place\", \"address\": { \"@type\": \"PostalAddress\", \"addressLocality\": \"Los Angeles\", \"addressRegion\": \"LA\" } }, \"email\": \"john.doe@email.com\", \"telephone\": \"555-984-394\" } ] } With a request in which your customer is asking just for the specific information that it’s going to show or use on a table to the user: GET api/members?fields=name,jobTitle { \"members\" : [ { \"name\": \"Sophia Hart\", \"jobTitle\" : \"Senior Executive\" }, { \"name\": \"John Doe\", \"jobTitle\": \"Sales Manager\" } ] } {call DocsList.render} {param section: $page /} {/call} ","srcFilePath":"src/pages/docs/recipes/sparse-fieldsets.md","id":"sparse-fieldsets","location":"/docs/recipes/sparse-fieldsets.html","url":"/docs/recipes/sparse-fieldsets.html"}},"childIds":["pagination","non-crud-operations","sparse-fieldsets","resource-embedding"]}},"childIds":["introduction","recipes","search"]},"updates":{"title":"Updates","description":"Check out what's new","updates":[{"version":"0.0.3","major":true,"features":[{"icon":"code-file","title":"Added 'Recipes' section.","description":"Recipes section will include small bits of useful help to add to your API features that can help with its evolvability."},{"icon":"code-file","title":"Introduction section in docs.","description":"The Guidelines section have been turned into Introduction section in docs."}]},{"version":"0.0.2","major":true,"features":[{"icon":"flash","title":"Added main information on landing page","description":"First version of the landing page with more info on the main concepts and why Evolvable APIs are needed."},{"icon":"code-file","title":"First draft of the Guidelines","description":"The Guidelines are a set of good practices and advice on what we should take into account in order to make our REST APIs evolvable."}]},{"version":"0.0.1","major":true,"features":[{"icon":"hammer","title":"Very first version of evolvable-apis.org","description":"This version is targeted to very early adopters. API Developers who believe there has to be a better way to do APIs so that they an evolve seamlessly over the years. And who want to participate and make it a reality."}]}],"content":" Beta ","srcFilePath":"src/pages/updates/index.soy","id":"updates","location":"/updates/","url":"/updates/"}},"childIds":["docs","updates"]}}